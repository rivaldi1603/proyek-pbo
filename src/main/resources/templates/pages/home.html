<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
  layout:decorate="~{layouts/base}" lang="id">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Workout Tracking System</title>
</head>

<body>
  <th:block layout:fragment="others-css">
    <style>
      /* Override body background to transparent to show the canvas if needed, 
         but we will place the canvas fixed at -1 z-index */
      body {
        background: transparent !important;
      }

      #floating-lines-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
        overflow: hidden;
        background-color: #000;
        /* Black background for the lines */
      }

      /* Make the card semi-transparent to see the background */
      .card {
        background-color: rgba(255, 255, 255, 0.9) !important;
        backdrop-filter: blur(10px);
      }
    </style>
  </th:block>

  <div layout:fragment="content">
    <!-- Background Container -->
    <div id="floating-lines-container"></div>

    <!-- Foreground Content Wrapper -->
    <div style="position: relative; z-index: 1; min-height: 80vh; display: flex; flex-direction: column;">

      <!-- Header (Top Left & Top Right) -->
      <div class="d-flex justify-content-between align-items-center p-4">
        <!-- Top Left: Title -->
        <h4 class="mb-0 fw-bold text-primary" style="text-shadow: 0 2px 4px rgba(255,255,255,0.8);">Dashboard</h4>

        <!-- Top Right: User Dropdown -->
        <div class="dropdown">
          <button
            class="btn btn-light dropdown-toggle d-flex align-items-center gap-2 border shadow-sm rounded-pill px-3 py-2"
            type="button" data-bs-toggle="dropdown" aria-expanded="false"
            style="background-color: rgba(255, 255, 255, 0.9);">
            <img th:if="${auth.profilePhoto != null}" th:src="@{'/uploads/' + ${auth.profilePhoto}}"
              class="rounded-circle" style="width: 32px; height: 32px; object-fit: cover;">
            <img th:unless="${auth.profilePhoto != null}"
              src="https://ui-avatars.com/api/?name=User&background=random&size=32" class="rounded-circle"
              style="width: 32px; height: 32px; object-fit: cover;">
            <span class="fw-semibold" th:text="${auth.name}">User</span>
          </button>
          <ul class="dropdown-menu dropdown-menu-end shadow-sm border-0 mt-2">
            <li><a class="dropdown-item py-2" th:href="@{/profile}"><i
                  class="bi bi-person-circle me-2 text-primary"></i>Profil Saya</a></li>
            <li>
              <hr class="dropdown-divider">
            </li>
            <li><a class="dropdown-item py-2 text-danger" th:href="@{/auth/logout}"><i
                  class="bi bi-box-arrow-right me-2"></i>Keluar</a></li>
          </ul>
        </div>
      </div>

      <!-- Center Content: Hero Card -->
      <div class="flex-grow-1 d-flex align-items-center justify-content-center p-4">
        <div class="card p-5 text-center shadow-lg border-0"
          style="max-width: 800px; width: 100%; background-color: rgba(255, 255, 255, 0.85); backdrop-filter: blur(10px); border-radius: 20px;">
          <div class="container-fluid py-3">
            <h1 class="display-5 fw-bold text-primary mb-3">"Every Workout is Progress"</h1>
            <p class="col-md-10 fs-5 mx-auto text-muted mb-4">
              Setiap langkah kecil membawamu lebih dekat ke tujuan. Tetap konsisten dan jadilah versi terbaik dari
              dirimu!
            </p>
            <a th:href="@{/activities}" class="btn btn-primary btn-lg px-5 gap-3 rounded-pill shadow-sm">
              <i class="bi bi-activity me-2"></i>Lihat Aktivitas Saya
            </a>
          </div>
        </div>
      </div>

    </div>
  </div>

  <th:block layout:fragment="others-js">
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        initFloatingLines();
      });

      function initFloatingLines() {
        const container = document.getElementById('floating-lines-container');
        if (!container) return;

        // Configuration (Restored default colorful waves)
        const config = {
          linesGradient: [], // Empty to use shader's default Blue/Pink waves
          enabledWaves: ['top', 'middle', 'bottom'],
          lineCount: [10, 15, 20],
          lineDistance: [8, 6, 4],
          topWavePosition: { x: 10.0, y: 0.5, rotate: -0.4 },
          middleWavePosition: { x: 5.0, y: 0.0, rotate: 0.2 },
          bottomWavePosition: { x: 2.0, y: -0.7, rotate: -1 },
          animationSpeed: 1,
          interactive: true,
          bendRadius: 5.0,
          bendStrength: -0.5,
          mouseDamping: 0.05,
          parallax: true,
          parallaxStrength: 0.2,
          mixBlendMode: 'screen'
        };

        // Shaders
        const vertexShader = `
          precision highp float;
          void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const fragmentShader = `
          precision highp float;

          uniform float iTime;
          uniform vec3  iResolution;
          uniform float animationSpeed;

          uniform bool enableTop;
          uniform bool enableMiddle;
          uniform bool enableBottom;

          uniform int topLineCount;
          uniform int middleLineCount;
          uniform int bottomLineCount;

          uniform float topLineDistance;
          uniform float middleLineDistance;
          uniform float bottomLineDistance;

          uniform vec3 topWavePosition;
          uniform vec3 middleWavePosition;
          uniform vec3 bottomWavePosition;

          uniform vec2 iMouse;
          uniform bool interactive;
          uniform float bendRadius;
          uniform float bendStrength;
          uniform float bendInfluence;

          uniform bool parallax;
          uniform float parallaxStrength;
          uniform vec2 parallaxOffset;

          uniform vec3 lineGradient[8];
          uniform int lineGradientCount;

          const vec3 BLACK = vec3(0.0);
          const vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;
          const vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;

          mat2 rotate(float r) {
            return mat2(cos(r), sin(r), -sin(r), cos(r));
          }

          vec3 background_color(vec2 uv) {
            vec3 col = vec3(0.0);

            float y = sin(uv.x - 0.2) * 0.3 - 0.1;
            float m = uv.y - y;

            col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));
            col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));
            return col * 0.5;
          }

          vec3 getLineColor(float t, vec3 baseColor) {
            if (lineGradientCount <= 0) {
              return baseColor;
            }

            vec3 gradientColor;
            
            if (lineGradientCount == 1) {
              gradientColor = lineGradient[0];
            } else {
              float clampedT = clamp(t, 0.0, 0.9999);
              float scaled = clampedT * float(lineGradientCount - 1);
              int idx = int(floor(scaled));
              float f = fract(scaled);
              int idx2 = min(idx + 1, lineGradientCount - 1);

              vec3 c1 = lineGradient[idx];
              vec3 c2 = lineGradient[idx2];
              
              gradientColor = mix(c1, c2, f);
            }
            
            return gradientColor * 0.5;
          }

          float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {
            float time = iTime * animationSpeed;

            float x_offset    = offset;
            float x_movement = time * 0.1;
            float amp         = sin(offset + time * 0.2) * 0.3;
            float y           = sin(uv.x + x_offset + x_movement) * amp;

            if (shouldBend) {
              vec2 d = screenUv - mouseUv;
              float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor
              float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;
              y += bendOffset;
            }

            float m = uv.y - y;
            return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;
          }

          void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;
            baseUv.y *= -1.0;
            
            if (parallax) {
              baseUv += parallaxOffset;
            }

            vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);
            
            // FIX: Initialize col with b to show the background waves!
            vec3 col = b; 

            vec2 mouseUv = vec2(0.0);
            if (interactive) {
              mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;
              mouseUv.y *= -1.0;
            }
            
            if (enableBottom) {
              for (int i = 0; i < bottomLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(bottomLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                
                float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                col += lineCol * wave(
                  ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),
                  1.5 + 0.2 * fi,
                  baseUv,
                  mouseUv,
                  interactive
                ) * 0.5; // Increased brightness
              }
            }

            if (enableMiddle) {
              for (int i = 0; i < middleLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(middleLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                
                float angle = middleWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                col += lineCol * wave(
                  ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),
                  2.0 + 0.15 * fi,
                  baseUv,
                  mouseUv,
                  interactive
                ) * 0.5; // Increased brightness
              }
            }

            if (enableTop) {
              for (int i = 0; i < topLineCount; ++i) {
                float fi = float(i);
                float t = fi / max(float(topLineCount - 1), 1.0);
                vec3 lineCol = getLineColor(t, b);
                
                float angle = topWavePosition.z * log(length(baseUv) + 1.0);
                vec2 ruv = baseUv * rotate(angle);
                ruv.x *= -1.0;
                col += lineCol * wave(
                  ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),
                  1.0 + 0.2 * fi,
                  baseUv,
                  mouseUv,
                  interactive
                ) * 0.3; // Increased brightness
              }
            }

            fragColor = vec4(col, 1.0);
          }

          void main() {
            vec4 color = vec4(0.0);
            mainImage(color, gl_FragCoord.xy);
            gl_FragColor = color;
          }
        `;

        // Helpers
        const getLineCount = (waveType) => {
          if (typeof config.lineCount === 'number') return config.lineCount;
          if (!config.enabledWaves.includes(waveType)) return 0;
          const index = config.enabledWaves.indexOf(waveType);
          return config.lineCount[index] ?? 6;
        };

        const getLineDistance = (waveType) => {
          if (typeof config.lineDistance === 'number') return config.lineDistance;
          if (!config.enabledWaves.includes(waveType)) return 0.1;
          const index = config.enabledWaves.indexOf(waveType);
          return config.lineDistance[index] ?? 0.1;
        };

        const hexToVec3 = (hex) => {
          let value = hex.trim();
          if (value.startsWith('#')) value = value.slice(1);
          let r = 255, g = 255, b = 255;
          if (value.length === 3) {
            r = parseInt(value[0] + value[0], 16);
            g = parseInt(value[1] + value[1], 16);
            b = parseInt(value[2] + value[2], 16);
          } else if (value.length === 6) {
            r = parseInt(value.slice(0, 2), 16);
            g = parseInt(value.slice(2, 4), 16);
            b = parseInt(value.slice(4, 6), 16);
          }
          return new THREE.Vector3(r / 255, g / 255, b / 255);
        };

        // Setup Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        camera.position.z = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        container.appendChild(renderer.domElement);

        // Uniforms
        const topLineCount = config.enabledWaves.includes('top') ? getLineCount('top') : 0;
        const middleLineCount = config.enabledWaves.includes('middle') ? getLineCount('middle') : 0;
        const bottomLineCount = config.enabledWaves.includes('bottom') ? getLineCount('bottom') : 0;

        const topLineDistance = config.enabledWaves.includes('top') ? getLineDistance('top') * 0.01 : 0.01;
        const middleLineDistance = config.enabledWaves.includes('middle') ? getLineDistance('middle') * 0.01 : 0.01;
        const bottomLineDistance = config.enabledWaves.includes('bottom') ? getLineDistance('bottom') * 0.01 : 0.01;

        const uniforms = {
          iTime: { value: 0 },
          iResolution: { value: new THREE.Vector3(1, 1, 1) },
          animationSpeed: { value: config.animationSpeed },
          enableTop: { value: config.enabledWaves.includes('top') },
          enableMiddle: { value: config.enabledWaves.includes('middle') },
          enableBottom: { value: config.enabledWaves.includes('bottom') },
          topLineCount: { value: topLineCount },
          middleLineCount: { value: middleLineCount },
          bottomLineCount: { value: bottomLineCount },
          topLineDistance: { value: topLineDistance },
          middleLineDistance: { value: middleLineDistance },
          bottomLineDistance: { value: bottomLineDistance },
          topWavePosition: { value: new THREE.Vector3(config.topWavePosition.x, config.topWavePosition.y, config.topWavePosition.rotate) },
          middleWavePosition: { value: new THREE.Vector3(config.middleWavePosition.x, config.middleWavePosition.y, config.middleWavePosition.rotate) },
          bottomWavePosition: { value: new THREE.Vector3(config.bottomWavePosition.x, config.bottomWavePosition.y, config.bottomWavePosition.rotate) },
          iMouse: { value: new THREE.Vector2(-1000, -1000) },
          interactive: { value: config.interactive },
          bendRadius: { value: config.bendRadius },
          bendStrength: { value: config.bendStrength },
          bendInfluence: { value: 0 },
          parallax: { value: config.parallax },
          parallaxStrength: { value: config.parallaxStrength },
          parallaxOffset: { value: new THREE.Vector2(0, 0) },
          lineGradient: { value: Array.from({ length: 8 }, () => new THREE.Vector3(1, 1, 1)) },
          lineGradientCount: { value: 0 }
        };

        if (config.linesGradient && config.linesGradient.length > 0) {
          const stops = config.linesGradient.slice(0, 8);
          uniforms.lineGradientCount.value = stops.length;
          stops.forEach((hex, i) => {
            const color = hexToVec3(hex);
            uniforms.lineGradient.value[i].set(color.x, color.y, color.z);
          });
        }

        const material = new THREE.ShaderMaterial({
          uniforms,
          vertexShader,
          fragmentShader
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        const clock = new THREE.Clock();

        // Resize
        const setSize = () => {
          const width = container.clientWidth || 1;
          const height = container.clientHeight || 1;
          renderer.setSize(width, height, false);
          uniforms.iResolution.value.set(renderer.domElement.width, renderer.domElement.height, 1);
        };
        setSize();
        window.addEventListener('resize', setSize);

        // Interaction
        const targetMouse = new THREE.Vector2(-1000, -1000);
        const currentMouse = new THREE.Vector2(-1000, -1000);
        let targetInfluence = 0;
        let currentInfluence = 0;
        const targetParallax = new THREE.Vector2(0, 0);
        const currentParallax = new THREE.Vector2(0, 0);

        const handlePointerMove = (event) => {
          // Since renderer is fixed full screen, we can use client coordinates directly
          const x = event.clientX;
          const y = event.clientY;
          const rect = renderer.domElement.getBoundingClientRect(); // Should be full screen
          const dpr = renderer.getPixelRatio();

          // Calculate mouse position for uniforms (relative to canvas)
          // We need to adjust if the canvas isn't exactly at 0,0 but it is fixed.
          // However, let's be safe and use rect.
          const relX = x - rect.left;
          const relY = y - rect.top;

          targetMouse.set(relX * dpr, (rect.height - relY) * dpr);
          targetInfluence = 1.0;

          if (config.parallax) {
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const offsetX = (relX - centerX) / rect.width;
            const offsetY = -(relY - centerY) / rect.height;
            targetParallax.set(offsetX * config.parallaxStrength, offsetY * config.parallaxStrength);
          }
        };

        const handlePointerLeave = () => {
          targetInfluence = 0.0;
        };

        if (config.interactive) {
          // Attach to window to capture events even when hovering over foreground elements
          window.addEventListener('pointermove', handlePointerMove);
          window.addEventListener('pointerleave', handlePointerLeave);
        }

        // Render Loop
        const renderLoop = () => {
          uniforms.iTime.value = clock.getElapsedTime();

          if (config.interactive) {
            currentMouse.lerp(targetMouse, config.mouseDamping);
            uniforms.iMouse.value.copy(currentMouse);

            currentInfluence += (targetInfluence - currentInfluence) * config.mouseDamping;
            uniforms.bendInfluence.value = currentInfluence;
          }

          if (config.parallax) {
            currentParallax.lerp(targetParallax, config.mouseDamping);
            uniforms.parallaxOffset.value.copy(currentParallax);
          }

          renderer.render(scene, camera);
          requestAnimationFrame(renderLoop);
        };
        renderLoop();
      }
    </script>
  </th:block>
</body>

</html>